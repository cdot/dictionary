<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>TrieNode.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Dictionary.html">Dictionary</a><ul class='methods'><li data-type='method'><a href="Dictionary.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Dictionary.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Dictionary.html#.findAnagrams#findAnagrams">findAnagrams</a></li><li data-type='method'><a href="Dictionary.html#.findHangmen#findHangmen">findHangmen</a></li><li data-type='method'><a href="Dictionary.html#.getSequenceRoots#getSequenceRoots">getSequenceRoots</a></li><li data-type='method'><a href="Dictionary.html#.hasSequence#hasSequence">hasSequence</a></li><li data-type='method'><a href="Dictionary.html#.hasWord#hasWord">hasWord</a></li><li data-type='method'><a href="Dictionary.html#.loadDAWG#loadDAWG">loadDAWG</a></li><li data-type='method'><a href="Dictionary.html#.match#match">match</a></li></ul></li><li><a href="Explorer.html">Explorer</a><ul class='methods'><li data-type='method'><a href="Explorer.html#.anagrams">anagrams</a></li><li data-type='method'><a href="Explorer.html#.arrangements">arrangements</a></li><li data-type='method'><a href="Explorer.html#.hangmen">hangmen</a></li><li data-type='method'><a href="Explorer.html#.list">list</a></li><li data-type='method'><a href="Explorer.html#.sequences">sequences</a></li></ul></li><li><a href="LetterNode.html">LetterNode</a><ul class='methods'><li data-type='method'><a href="LetterNode.html#.add#add">add</a></li><li data-type='method'><a href="LetterNode.html#.buildLists#buildLists">buildLists</a></li><li data-type='method'><a href="LetterNode.html#.decode#decode">decode</a></li><li data-type='method'><a href="LetterNode.html#.eachLongWord#eachLongWord">eachLongWord</a></li><li data-type='method'><a href="LetterNode.html#.eachNode#eachNode">eachNode</a></li><li data-type='method'><a href="LetterNode.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="LetterNode.html#.findWordsThatUse#findWordsThatUse">findWordsThatUse</a></li><li data-type='method'><a href="LetterNode.html#.hangmen#hangmen">hangmen</a></li><li data-type='method'><a href="LetterNode.html#.match#match">match</a></li></ul></li><li><a href="Trie.html">Trie</a><ul class='methods'><li data-type='method'><a href="Trie.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Trie.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Trie.html#.encode#encode">encode</a></li><li data-type='method'><a href="Trie.html#.generateDAWG#generateDAWG">generateDAWG</a></li></ul></li><li><a href="TrieNode.html">TrieNode</a><ul class='methods'><li data-type='method'><a href="TrieNode.html#.encode#encode">encode</a></li><li data-type='method'><a href="TrieNode.html#.findChild#findChild">findChild</a></li><li data-type='method'><a href="TrieNode.html#.insertChild#insertChild">insertChild</a></li><li data-type='method'><a href="TrieNode.html#.prune#prune">prune</a></li><li data-type='method'><a href="TrieNode.html#.replaceRedundantNodes#replaceRedundantNodes">replaceRedundantNodes</a></li><li data-type='method'><a href="TrieNode.html#.sameSubtrie#sameSubtrie">sameSubtrie</a></li><li data-type='method'><a href="TrieNode.html#.toString#toString">toString</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">TrieNode.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2019-2022 Crawford Currie http://c-dot.co.uk*/

import { LetterNode } from "./LetterNode.js";

let nodeIds = 0;

/**
 * A Trie/DAWG node.
 * Represents a letter in a set of words.  It has pointers to a
 * child list representing the next letters that can follow this
 * letter, and a next pointer to the next alternative to this
 * letter in the child list of it's parent node.  Note this is
 * only used while generating a DAWG from a lexicon. TrieNodes are
 * serialised using the above structure but are then rebuilt using
 * {@linkcode LetterNode}s at the sharp end.
 */
class TrieNode {
  /**
   * The letter at this node
   * @member {string}
   */
  letter = undefined;

  /**
   * Unique ID for this node, purely used for debugging
   * @member {number}
   */
  id = -1;

  /**
   * Pointer to the next alternative to this letter
   * @member {TrieNode}
   */
  next = null;

  /**
   * Pointer to the first next letter if this letter is matched
   * @member {TrieNode}
   */
  child = null;

  /**
   * Marker for a valid end-of-word node
   * @member {boolean}
   */
  isEndOfWord = false;

  /**
   * Marker for the first child under a parent node. This is
   * used when the node is arrived at other than through the
   * parent
   * @member {boolean}
   */
  isFirstChild = false;

  /**
   * Will be set if the node is to be pruned after DAWG generation
   * @member {boolean}
   */
  isPruned = false;

  /**
   * Maximum number of nodes under this node (iei remaining length
   * of the longest word this node partiipates in)
   * @member {number}
   */
  maxChildDepth = 0;

  /**
   * Number of child nodes under this node - used for optimisation
   * @member {number}
   */
  numberOfChildren = 0;

  /**
   * Index of the node in the encoded DAWG, assigned when the
   * encoding is generated
   * @member {number}
   */
  index = -1;

  /**
   * @param {string} letter codepoint
   * @param {TrieNode} next next node pointer
   * @param {boolean} isWordEnding true if this is an end-of-word node
   * @param {number} starterDepth The maximum depth below this
   * node before the end-of-word is reached, for the first word
   * added
   * @param {boolean} isFirstChild is the first child of the parent node
   */
  constructor(letter, next, isWordEnding, starterDepth, isFirstChild) {
    this.letter = letter;
    this.next = next;
    this.isEndOfWord = isWordEnding;
    this.maxChildDepth = starterDepth;
    this.isFirstChild = isFirstChild;
    this.id = nodeIds++;
  }

  /* istanbul ignore next */
  /**
   * Debug
   * @param {boolean} deeply true to expand child nodes
   */
  toString(deeply) {
    let simpler = `{${this.id} ${this.letter}`;

    if (this.isEndOfWord)
      simpler += ".";
    if (this.child) {
      simpler += "+";
      if (deeply)
        simpler += this.child.toString(deeply);
    }
    simpler += "}";
    if (this.next) {
      simpler += "-";
      if (deeply)
        simpler += this.next.toString(deeply);
    }

    return simpler;
  }

  /**
   * Mark a node as pruned, and recursively mark every node
   * under and after it as well
   * @return {number} the total number of nodes pruned as a result
   */
  prune() {
    //console.debug(`Pruning ${this}`);
    this.isPruned = true;

    let result = 0;
    if (this.next)
      result += this.next.prune();

    if (this.child)
      result += this.child.prune();

    return result + 1;
  }

  /**
   * @callback TrieNode~wordCallback
   * @param {TrieNode} nodes list of nodes on the path
   * from the root to the end of the word
   */

  /**
   * Depth-first tree walk. Will visit ends of words in
   * sorted order.
   * @param {TrieNode[]} nodes list of nodes visited to create the word
   * @param {TrieNode~wordCallback} cb callback function
   * @private
   */
  eachWord(nodes, cb) {

    nodes.push(this);

    if (this.isEndOfWord)
      cb(nodes);

    if (this.child)
      this.child.eachWord(nodes, cb);

    nodes.pop();

    if (this.next)
      this.next.eachWord(nodes, cb);
  }

  eachNode(cb) {
    cb(this);
    if (this.next)
      this.next.eachNode(cb);
    if (this.child)
      this.child.eachNode(cb);
  }

  /**
   * Search along this's child next chain for a node with the
   * given letter.
   * @param {string} thisLetter letter to look for
   * @return {TrieNode} the node found, or null
   */
  findChild(thisLetter) {
    let result = this.child;
    while (result) {
      if (result.letter === thisLetter)
        return result;
      if (result.letter > thisLetter)
        break;
      result = result.next;
    }
    return null;
  }

  /**
   * Insert a letter in the child list of this node. The child
   * list is sorted on letter
   * @param {string} thisLetter letter to add
   * @param {boolean} wordEnder true if this is the end of a word
   * @param {number} startDepth depth of shallowest node
   */
  insertChild(thisLetter, wordEnder, startDepth) {
    this.numberOfChildren++;

    if (!this.child) {
      // child list does not exist yet
      this.child = new TrieNode(
        thisLetter, null, wordEnder, startDepth, true);
      return;
    }

    if (this.child.letter > thisLetter) {
      // thisLetter should be the first in the child list
      this.child.isFirstChild = false;
      this.child = new TrieNode(
        thisLetter, this.child, wordEnder, startDepth, true);
      return;
    }

    // thisLetter is not the first in the list
    let child = this.child;
    while (child.next) {
      if (child.next.letter > thisLetter)
        break;
      child = child.next;
    }
    child.next = new TrieNode(
      thisLetter, child.next, wordEnder, startDepth, false);
  }

  /**
   * Determine if this and other are the parent nodes
   * of equal Trie branches.
   * @param {TrieNode} other other tree to compare
   * @return {boolean} if the are the same
   */
  sameSubtrie(other) {
    //console.debug("CMP",this.toString(), !other ? "null" : other.toString());
    if (other === this) // identity
      return true;

    if (other === null
        || other.letter !== this.letter
        || other.maxChildDepth !== this.maxChildDepth
        || other.numberOfChildren !== this.numberOfChildren
        || other.isEndOfWord !== this.isEndOfWord
        || !this.child &amp;&amp; other.child
        || this.child &amp;&amp; !other.child
        || !this.next &amp;&amp; other.next
        || this.next &amp;&amp; !other.next)
      return false;

    if (this.child &amp;&amp; !this.child.sameSubtrie(other.child))
      return false;

    if (this.next &amp;&amp; !this.next.sameSubtrie(other.next))
      return false;

    return true;
  }

  /**
   * Returns the first node in the red[maxChildDepth], that is
   * identical to 'this'. If the function returns 'this'
   * then it is the first of its kind in the
   * Trie.
   * @param {TrieNode[][]} red reduction structure
   * @return {TrieNode}
   * @private
   */
  findSameSubtrie(red) {
    //return red[this.maxChildDepth].find(n => this.sameSubtrie(n));
    let x;
    for (x = 0; x &lt; red[this.maxChildDepth].length; x++)
      if (this.sameSubtrie(red[this.maxChildDepth][x]))
        break;
    /* istanbul ignore if */
    if (red[this.maxChildDepth][x].isPruned)
      throw Error("Same subtrie equivalent is pruned!");
    return red[this.maxChildDepth][x];
  }

  /**
   * Recursively replaces all redundant nodes in a trie with their
   * first equivalent.
   * @param {TrieNode[][]} red reduction structure
   * @return {number} no of nodes replaced
   */
  replaceRedundantNodes(red) {

    if (!this.next &amp;&amp; !this.child)
      // Leaf node
      return 0;

    let trimmed = 0;
    if (this.child) {
      if (this.child.isPruned) {
        //console.debug(`Trimming ${this.child}`);
        // we have found a node that has been tagged for
        // as pruned, so let us replace it with its first
        // equivalent which isn't tagged.
        this.child = this.child.findSameSubtrie(red);
        /* istanbul ignore if */
        if (this.child === null)
          throw Error("Something horrible");
        trimmed++;
      } else
        trimmed += this.child.replaceRedundantNodes(red);
    }

    // Traverse the rest of the 'Trie', but a 'TrieNode' that is
    // not a direct child will never be directly replaced.
    // This will allow the resulting 'Dawg' to fit into a
    // contiguous array of node lists.
    if (this.next)
      trimmed += this.next.replaceRedundantNodes(red);

    return trimmed;
  }

  /**
   * Encode the node in a pair of integers. Requires node indices to have
   * been established.
   * @return {number[]} array with the 2-integer encoding
   */
  encode() {
    const array = [ this.letter.codePointAt(0) ];
    let numb = 0;
    if (this.child)
      numb |= (this.child.index &lt;&lt; LetterNode.CHILD_INDEX_SHIFT);
    if (this.isEndOfWord)
      numb |= LetterNode.END_OF_WORD_BIT_MASK;
    if (!this.next)
      numb |= LetterNode.END_OF_LIST_BIT_MASK;
    array.push(numb);
    return array;
  }
}

export { TrieNode };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Tue Feb 13 2024 08:35:23 GMT+0000 (Greenwich Mean Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
