<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Dictionary.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Dictionary.html">Dictionary</a><ul class='methods'><li data-type='method'><a href="Dictionary.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Dictionary.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Dictionary.html#.findAnagrams#findAnagrams">findAnagrams</a></li><li data-type='method'><a href="Dictionary.html#.findHangmen#findHangmen">findHangmen</a></li><li data-type='method'><a href="Dictionary.html#.getSequenceRoots#getSequenceRoots">getSequenceRoots</a></li><li data-type='method'><a href="Dictionary.html#.hasSequence#hasSequence">hasSequence</a></li><li data-type='method'><a href="Dictionary.html#.hasWord#hasWord">hasWord</a></li><li data-type='method'><a href="Dictionary.html#.loadDAWG#loadDAWG">loadDAWG</a></li><li data-type='method'><a href="Dictionary.html#.match#match">match</a></li></ul></li><li><a href="Explorer.html">Explorer</a><ul class='methods'><li data-type='method'><a href="Explorer.html#.anagrams">anagrams</a></li><li data-type='method'><a href="Explorer.html#.arrangements">arrangements</a></li><li data-type='method'><a href="Explorer.html#.hangmen">hangmen</a></li><li data-type='method'><a href="Explorer.html#.list">list</a></li><li data-type='method'><a href="Explorer.html#.sequences">sequences</a></li></ul></li><li><a href="LetterNode.html">LetterNode</a><ul class='methods'><li data-type='method'><a href="LetterNode.html#.add#add">add</a></li><li data-type='method'><a href="LetterNode.html#.buildLists#buildLists">buildLists</a></li><li data-type='method'><a href="LetterNode.html#.decode#decode">decode</a></li><li data-type='method'><a href="LetterNode.html#.eachLongWord#eachLongWord">eachLongWord</a></li><li data-type='method'><a href="LetterNode.html#.eachNode#eachNode">eachNode</a></li><li data-type='method'><a href="LetterNode.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="LetterNode.html#.findWordsThatUse#findWordsThatUse">findWordsThatUse</a></li><li data-type='method'><a href="LetterNode.html#.hangmen#hangmen">hangmen</a></li><li data-type='method'><a href="LetterNode.html#.match#match">match</a></li></ul></li><li><a href="Trie.html">Trie</a><ul class='methods'><li data-type='method'><a href="Trie.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Trie.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Trie.html#.encode#encode">encode</a></li><li data-type='method'><a href="Trie.html#.generateDAWG#generateDAWG">generateDAWG</a></li></ul></li><li><a href="TrieNode.html">TrieNode</a><ul class='methods'><li data-type='method'><a href="TrieNode.html#.encode#encode">encode</a></li><li data-type='method'><a href="TrieNode.html#.findChild#findChild">findChild</a></li><li data-type='method'><a href="TrieNode.html#.insertChild#insertChild">insertChild</a></li><li data-type='method'><a href="TrieNode.html#.prune#prune">prune</a></li><li data-type='method'><a href="TrieNode.html#.replaceRedundantNodes#replaceRedundantNodes">replaceRedundantNodes</a></li><li data-type='method'><a href="TrieNode.html#.sameSubtrie#sameSubtrie">sameSubtrie</a></li><li data-type='method'><a href="TrieNode.html#.toString#toString">toString</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Dictionary.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2019-2022 Crawford Currie http://c-dot.co.uk*/

import { LetterNode } from "./LetterNode.js";

/**
 * Dictionary using a Directed Acyclic Word Graph (DAWG) in the
 * format generated by compress.js
 *
 * Note that the DAWG uses letter indices, and not actual characters, to
 * represent code points. To use this dictionary you also need an
 * alphabet of code points sorted in the same order as that used to
 * generate the DAWG.
 * @class Dictionary
 */
class Dictionary {

  /**
   * Cache of dictionaries
   * @member {Dictionary[]}
   * @private
   */
  static cache = [];

  /**
   * @param {string} name of the dictionary
   * @private
   */
  constructor(name) {
    /**
     * First node in the dictionary.
     * @member {LetterNode?}
     */
    this.root = undefined;

    /**
     * List of valid start points, such that at least one
     * start point must match() for any sequence of chars, or
     * there can't possibly be a word. Map from letter to a
     * LetterNode or a list of LetterNode.
     * @private
     */
    this.sequenceRoots = undefined;

    /**
     * List of valid start points, such that at least one
     * start point must match() for any sequence of chars,
     * or there can't possibly be a word.
     * @member {string}
     */
    this.name = name;
  }

  /**
   * Load a DAG, as generated by dictionary_compressor.js. This is
   * destructive; anything already in the dictionary will be
   * discarded.
   * @param {(Buffer|Array)?} data the DAWG data.
   * @return {Dictionary} this
   */
  loadDAWG(data) {
    const dv = new DataView(data);
    let index = 0;
    const numberOfNodes = dv.getUint32(4 * index++);
    const nodes = [];
    for (let i = 0; i &lt; numberOfNodes; i++) {
      const letter = dv.getUint32(4 * index++);
      const node = new LetterNode(String.fromCodePoint(letter));
      node.decode(i, dv.getUint32(4 * index++));
      //console.log(`${nodes.length} `,node);
      nodes.push(node);
    }
    // Convert node indices to pointers
    for (let i = 0; i &lt; nodes.length; i++) {
      const node = nodes[i];
      if (typeof node.next === "number")
        node.next = nodes[node.next];
      if (typeof node.child === "number")
        node.child = nodes[node.child];
    }
    this.root = nodes[0];

    return this;
  }

  /*
   * Cross-link nodes in the dictionary with nodes before and
   * after them, for fast traversal.
   * @return {Dictionary} this
   */
  addLinks() {
    // Build forward and back lists
    this.root.buildLists();
    return this;
  }

  /**
   * @callback Dictionary~wordCallback
   * @param {string} word Word found
   * @param {LetterNode} node Node where word was terminated
   */

  /**
   * Apply the callback to each of the words represented in the DAWG
   * (potentially huge!)
   * @param {Dictionary~wordCallback} callback function
   */
  eachWord(callback) {
    return this.root.eachWord("", callback);
  }

  /**
   * Return the LetterNode that matches the last character
   * in chars, starting from the root / first character.
   * @param {string} chars characters that may be the root of a word
   * @return {LetterNode} node found, or undefined
   */
  match(chars) {
    return this.root.match(chars, 0);
  }

  /**
   * Check if a word is in the dictionary
   * @param {string} chars a word to check
   * @return {boolean} true if the word is found, false otherwise
   */
  hasWord(chars) {
    const m = this.root.match(chars, 0);
    return m &amp;&amp; m.isEndOfWord;
  }

  /**
   * Find anagrams of a set of letters. An anagram is defined as any
   * complete (2 or more characters) word that uses all or some of the
   * letters passed in.
   * @param {string} theChars the letters, ' ' for an any-letter wildcard.
   * @return {Object&lt;string, string>} a map of actual words to the letter
   * sequence (using ' ' for blanks) that matched.
   */
  findAnagrams(theChars) {
    theChars = theChars.toUpperCase();

    if (theChars.length &lt; 2)
      throw Error(`Dictionary: '${theChars}' is Too short to find anagrams`);

    // Sort the list of characters.
    // Sorting makes it easier to debug.
    const ac = theChars.split("");//.sort();

    //console.log('Sorted chars', ac);
    const foundWords = {};
    this.root.findWordsThatUse(ac, "", "", foundWords);
    return foundWords;
  }

  /** 
   * Find hangman matches for a set of letters. A hangman match is any
   * word(s) that match against an ordered set of letters, using a space
   * for an any-letter wildcard. For example, "EXAMPLE" is a hangman match
   * for "E AM LE".
   * @param {string} theChars the letters, ' ' for an any-letter wildcard.
   * @return {string[]} the list of words that matched.
   */
  findHangmen(theChars) {
    theChars = theChars.toUpperCase();
    const list = [];
    this.root.hangmen(theChars, 0, "", list);
    return list;
  }

  /**
   * For each letter of the alphabet, establish a list of valid
   * start points, such that at least one start point must match()
   * for any sequence of chars, or there can't possibly be a word.
   * @private
   */
  createSequenceRoots() {
    this.sequenceRoots = {};
    this.root.eachNode(node => {
      if (!this.sequenceRoots[node.letter])
        this.sequenceRoots[node.letter] = [node];
      else
        this.sequenceRoots[node.letter].push(node);
      return true;
    });
    //console.log(`Created sequence roots for dictionary "${this.name}"`);
  }

  /**
   * Get a list of the sequence roots for ch. The sequence roots
   * are all those nodes that represent the character in any word.
   * From a sequence root we can follow post or pre to extend the
   * word in either direction.
   * @param {string} ch character to find roots for
   * @return {LetterNode[]} list of the roots
   */
  getSequenceRoots(ch) {
    if (!this.sequenceRoots)
      this.createSequenceRoots();
    return this.sequenceRoots[ch] || [];
  }

  /**
   * Do the work of adding a word, but don't do anything about
   * pre-/post- links or sequence roots.
   * @private
   */
  _addWord(word) {
    /* istanbul ignore if */
    if (word.length === 0)
      return false;
    if (!this.root)
      this.root = new LetterNode(word.charAt(0));
    else if (this.hasWord(word))
      return false;
    this.root.add(word);
    return true;
  }

  /**
   * Add a word to the dictionary. No attempt is made at compression.
   * Note that previously retrieved sequence roots will no longer
   * be valid after the word is added and will need to be recomputed.
   * Note that we support single character words here, but
   * word games are limited to 2 letter or more. It's up to
   * the caller to enforce such constraints.
   * @return {boolean} true if the word needed to be added, false
   * if it was empty or already there.
   */
  addWord(word) {
    if (this._addWord(word)) {
      // Don't recreate, that will be done on demand
      delete this.sequenceRoots;
      // Re-build forward and back lists. This could be done
      // incrementally, but it's a reasonably cheap operation so....
      this.root.buildLists();
      return true;
    }
    return false;
  }

  /**
   * Find start node for the character sequence in the sequence
   * index i.e. it forms a valid sub-part of a word in the
   * dictionary. This way we can quickly eliminate sequences
   * such as "QX" which are never found in the dictionary. Note
   * that we don't have any way to reproduce the words that the
   * sequence is a valid part of; that's not the point, this is
   * intended to help eliminate invalid sequences when extending
   * a word backwards from a seed letter.
   * @param {string} seq letter sequence
   * @private
   */
  findSequence(seq) {
    if (!this.sequenceRoots)
      this.createSequenceRoots();
    const roots = this.sequenceRoots[seq.charAt(0)];
    if (!roots || roots.length &lt;= 0)
      throw Error(`Dictionary: '${seq}' has no roots`);
    for (let root of roots) {
      if (root.match(seq, 0))
        return root;
    }
    // Not found
    return null;
  }

  /**
   * Return true if a start node for the character sequence is found
   * in the sequence index i.e. it forms a valid sub-part of a word
   * in the dictionary. This way we can quickly eliminate sequences
   * such as "QX" which are never found in the dictionary. Note that
   * we don't have any way to reproduce the words that the sequence
   * is a valid part of; that's not the point, this is intended to help
   * eliminate invalid sequences when extending a word backwards from
   * a seed letter.
   * @param {string} seq letter sequence
   * @return {boolean} if a start node exists
   */
  hasSequence(seq) {
    return this.findSequence(seq) != null;
  }
}

export { Dictionary }
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Tue Feb 13 2024 08:35:23 GMT+0000 (Greenwich Mean Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
