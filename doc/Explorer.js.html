<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Explorer.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Dictionary.html">Dictionary</a><ul class='methods'><li data-type='method'><a href="Dictionary.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Dictionary.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Dictionary.html#.findAnagrams#findAnagrams">findAnagrams</a></li><li data-type='method'><a href="Dictionary.html#.findHangmen#findHangmen">findHangmen</a></li><li data-type='method'><a href="Dictionary.html#.getSequenceRoots#getSequenceRoots">getSequenceRoots</a></li><li data-type='method'><a href="Dictionary.html#.hasSequence#hasSequence">hasSequence</a></li><li data-type='method'><a href="Dictionary.html#.hasWord#hasWord">hasWord</a></li><li data-type='method'><a href="Dictionary.html#.loadDAWG#loadDAWG">loadDAWG</a></li><li data-type='method'><a href="Dictionary.html#.match#match">match</a></li></ul></li><li><a href="Explorer.html">Explorer</a><ul class='methods'><li data-type='method'><a href="Explorer.html#.anagrams">anagrams</a></li><li data-type='method'><a href="Explorer.html#.arrangements">arrangements</a></li><li data-type='method'><a href="Explorer.html#.hangmen">hangmen</a></li><li data-type='method'><a href="Explorer.html#.list">list</a></li><li data-type='method'><a href="Explorer.html#.sequences">sequences</a></li></ul></li><li><a href="LetterNode.html">LetterNode</a><ul class='methods'><li data-type='method'><a href="LetterNode.html#.add#add">add</a></li><li data-type='method'><a href="LetterNode.html#.buildLists#buildLists">buildLists</a></li><li data-type='method'><a href="LetterNode.html#.decode#decode">decode</a></li><li data-type='method'><a href="LetterNode.html#.eachLongWord#eachLongWord">eachLongWord</a></li><li data-type='method'><a href="LetterNode.html#.eachNode#eachNode">eachNode</a></li><li data-type='method'><a href="LetterNode.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="LetterNode.html#.findWordsThatUse#findWordsThatUse">findWordsThatUse</a></li><li data-type='method'><a href="LetterNode.html#.hangmen#hangmen">hangmen</a></li><li data-type='method'><a href="LetterNode.html#.match#match">match</a></li></ul></li><li><a href="Trie.html">Trie</a><ul class='methods'><li data-type='method'><a href="Trie.html#.addWord#addWord">addWord</a></li><li data-type='method'><a href="Trie.html#.eachWord#eachWord">eachWord</a></li><li data-type='method'><a href="Trie.html#.encode#encode">encode</a></li><li data-type='method'><a href="Trie.html#.generateDAWG#generateDAWG">generateDAWG</a></li></ul></li><li><a href="TrieNode.html">TrieNode</a><ul class='methods'><li data-type='method'><a href="TrieNode.html#.encode#encode">encode</a></li><li data-type='method'><a href="TrieNode.html#.findChild#findChild">findChild</a></li><li data-type='method'><a href="TrieNode.html#.insertChild#insertChild">insertChild</a></li><li data-type='method'><a href="TrieNode.html#.prune#prune">prune</a></li><li data-type='method'><a href="TrieNode.html#.replaceRedundantNodes#replaceRedundantNodes">replaceRedundantNodes</a></li><li data-type='method'><a href="TrieNode.html#.sameSubtrie#sameSubtrie">sameSubtrie</a></li><li data-type='method'><a href="TrieNode.html#.toString#toString">toString</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Explorer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*Copyright (C) 2019-2022 Crawford Currie http://c-dot.co.uk*/

import { Dictionary } from "./Dictionary.js";

/**
 * Different ways to explore a dictionary
 */
class Explorer {

  /**
   * Determine if the words passed are valid sub-sequences of any
   * word in the dictionary e.g. 'UZZL' is a valid sub-sequence in
   * an English dictionary as it is found in 'PUZZLE', but 'UZZZL'
   * isn't.
   * @param {Dictionary} dictionary dawg to explore
   * @param {string[]?} words list of words to check
   * @param {function} report reporter function, same signature as console.log
   */
  static sequences(dictionary, words, report) {
    if (!(dictionary instanceof Dictionary))
      throw Error("Not a Dictionary");
    const valid = [];
    report(`Valid sequences:`);
    for (let w of words) {
      if (dictionary.hasSequence(w))
        report(w);
    }
  }

  /**
   * Find anagrams of the words that use all the letters. `.`
   * works as a character wildcard.
   * @param {Dictionary} dictionary dawg to explore
   * @param {string[]?} words list of words to check
   * @param {function} report reporter function, same signature as console.log
   */
  static anagrams(dictionary, words, report) {
    if (!words || words.length === 0)
      throw Error("Need letters to find anagrams of");

    for (const w of words) {
      let anag = Object.keys(dictionary.findAnagrams(w.replace(/\./g, " ")));
      anag = anag.filter(word => word.length === w.length);
      report(`${anag.length} words found in "${w}":`);
      anag.forEach(w => report(w));
    }
  }

  /**
   * Find words that hangman match all the letters. `.`
   * works as a character wildcard.
   * @param {Dictionary} dictionary dawg to explore
   * @param {string[]?} words list of words to check
   * @param {function} report reporter function, same signature as console.log
   */
  static hangmen(dictionary, words, report) {
    if (!words || words.length === 0)
      throw Error("Need letters to find hangman matches for");

    for (const w of words) {
      const matches =
            dictionary.findHangmen(w.replace(/\./g, " "));
      matches.forEach(w => report(w));
    }
  }

  /**
   * Find arrangements of the letters in the words e.g. `UIE` is a
   * an arrangement of the letters in `QUIET`, as is `EIU` and `IUE`.
   * @param {Dictionary} dictionary dawg to explore
   * @param {string[]?} words list of words to check
   * @param {function} report reporter function, same signature as console.log
   */
  static arrangements(dictionary, words, report) {
    if (!words || words.length === 0)
      throw Error("Need letters to find arrangements of");

    for (const w of words) {
      let anag = Object.keys(dictionary.findAnagrams(w));
      report(`${anag.length} words found in "${w}":`);
      anag.forEach(w => report(w));
    }
  }

  /**
   * List all the words in the dictionary. If `words` is given,
   * list all dictionary entries that start with one of the words.
   * @param {Dictionary} dictionary dawg to explore
   * @param {string[]?} words list of words to check
   * @param {function} report reporter function, same signature as console.log
   */
  static list(dictionary, words, report) {
    if (!words || words.length === 0) {
      dictionary.eachWord((s, n) => report(s));
      return;
    }

    // Dump of words that match words
    const biglist = {};
    words.map(w => {
      const word = w.toUpperCase();
      const node = dictionary.match(word);
      if (node)
        return { word: word, node: node };
      return undefined;
    })
    .filter(r => r)
    .sort((a, b) => {
      return a.word.length > b.word.length ? -1 :
      a.word.length === b.word.length ? 0 : 1;
    })
    .map(root => {
      if (root.node.child) {
        let list = [];
        biglist[root.word] = true;
        root.node.child.eachWord(root.word, w => list.push(w));

        list = list.filter(w => !biglist[w]);
        list.forEach(w => biglist[w] = true);

        report(list.map(w => `${root.word} -- ${w}`).join("\n"));
      }
    });
  }
}

export { Explorer };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Tue Feb 13 2024 08:35:23 GMT+0000 (Greenwich Mean Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
