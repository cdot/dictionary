var t={d:(e,i)=>{for(var r in i)t.o(i,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:i[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{Xy:()=>r,bC:()=>n,sn:()=>i,BE:()=>d,Yk:()=>h});class i{static END_OF_WORD_BIT_MASK=1;static END_OF_LIST_BIT_MASK=2;static CHILD_INDEX_SHIFT=2;static CHILD_INDEX_BIT_MASK=1073741823;next;child;isEndOfWord=!1;preNodes;preLetters;postNodes;postLetters;constructor(t){this.letter=t}eachWord(t,e){let i=this;for(;i;)i.isEndOfWord&&e(t+i.letter,i),i.child&&i.child.eachWord(t+i.letter,e),i=i.next}eachLongWord(t,e){let i=this;for(;i;)i.child?i.child.eachLongWord(t+i.letter,e):i.isEndOfWord&&e(t+i.letter,i),i=i.next}eachNode(t){let e=this;for(;e;){if(!t(e))return!1;if(e.child&&!e.child.eachNode(t))return!1;e=e.next}return!0}add(t){let e=this,r=!1;for(;e;)if(e.letter===t.charAt(0)){if(1===t.length)return e.isEndOfWord||(r=!0,e.isEndOfWord=!0),r;if(t=t.substring(1),!e.child||e.child.letter>t.charAt(0)){const n=e.child;e.child=new i(t.charAt(0)),r=!0,e.child.next=n}e=e.child}else if(!e.next||e.next.letter>t.charAt(0)){const n=e.next;e.next=new i(t.charAt(0)),r=!0,e.next.next=n}else e=e.next;return assert.fail(`Unreachable '${t}`)}buildLists(t){let e=this;for(;e;)e.preNodes=[],e.preLetters=[],e.postNodes=[],e.postLetters=[],t&&(e.preNodes.push(t),e.preLetters.push(t.letter),t.postNodes.push(e),t.postLetters.push(e.letter)),e.child&&e.child.buildLists(e),e=e.next}match(t,e){let i=this;for(;i;){if(i.letter===t[e]){if(e===t.length-1)return i;if(i.child)return i.child.match(t,e+1)}i=i.next}return null}hangmen(t,e,i,r){let n=this;const s=t[e];for(;n;)" "!==s&&n.letter!==s||(n.isEndOfWord&&e===t.length-1&&r.push(i+n.letter),e<t.length-1&&n.child&&n.child.hangmen(t,e+1,i+n.letter,r)),n=n.next}findWordsThatUse(t,e,i,r){let n=this;for(;n;){let s=t.indexOf(n.letter);if(s<0&&(s=t.indexOf(" ")),s>=0){const h=t[s];if(n.isEndOfWord&&(r[e+n.letter]=i+h),t.length>1){t.splice(s,1);let d=n.child;for(;d;)d.findWordsThatUse(t,e+n.letter,i+h,r),d=d.next;t.splice(s,0,h)}}n=n.next}}decode(t,e){return 0!=(e&i.END_OF_WORD_BIT_MASK)&&(this.isEndOfWord=!0),0==(e&i.END_OF_LIST_BIT_MASK)&&(this.next=t+1),(e>>i.CHILD_INDEX_SHIFT&i.CHILD_INDEX_BIT_MASK)>0&&(this.child=e>>i.CHILD_INDEX_SHIFT&i.CHILD_INDEX_BIT_MASK),this}}class r{static cache=[];constructor(t){this.root=void 0,this.sequenceRoots=void 0,this.name=t}loadDAWG(t){const e=new DataView(t);let r=0;const n=e.getUint32(4*r++),s=[];for(let t=0;t<n;t++){const n=e.getUint32(4*r++),h=new i(String.fromCodePoint(n));h.decode(t,e.getUint32(4*r++)),s.push(h)}for(let t=0;t<s.length;t++){const e=s[t];"number"==typeof e.next&&(e.next=s[e.next]),"number"==typeof e.child&&(e.child=s[e.child])}return this.root=s[0],this}addLinks(){return this.root.buildLists(),this}eachWord(t){return this.root.eachWord("",t)}match(t){return this.root.match(t,0)}hasWord(t){const e=this.root.match(t,0);return e&&e.isEndOfWord}findAnagrams(t){if((t=t.toUpperCase()).length<2)throw Error(`Dictionary: '${t}' is Too short to find anagrams`);const e=t.split(""),i={};return this.root.findWordsThatUse(e,"","",i),i}findHangmen(t){t=t.toUpperCase();const e=[];return this.root.hangmen(t,0,"",e),e}createSequenceRoots(){this.sequenceRoots={},this.root.eachNode((t=>(this.sequenceRoots[t.letter]?this.sequenceRoots[t.letter].push(t):this.sequenceRoots[t.letter]=[t],!0)))}getSequenceRoots(t){return this.sequenceRoots||this.createSequenceRoots(),this.sequenceRoots[t]||[]}_addWord(t){if(0===t.length)return!1;if(this.root){if(this.hasWord(t))return!1}else this.root=new i(t.charAt(0));return this.root.add(t),!0}addWord(t){return!!this._addWord(t)&&(delete this.sequenceRoots,this.root.buildLists(),!0)}findSequence(t){this.sequenceRoots||this.createSequenceRoots();const e=this.sequenceRoots[t.charAt(0)];if(!e||e.length<=0)throw Error(`Dictionary: '${t}' has no roots`);for(let i of e)if(i.match(t,0))return i;return null}hasSequence(t){return null!=this.findSequence(t)}}class n{static sequences(t,e,i){if(!(t instanceof r))throw Error("Not a Dictionary");i("Valid sequences:");for(let r of e)t.hasSequence(r)&&i(r)}static anagrams(t,e,i){if(!e||0===e.length)throw Error("Need letters to find anagrams of");for(const r of e){let e=Object.keys(t.findAnagrams(r.replace(/\./g," ")));e=e.filter((t=>t.length===r.length)),i(`${e.length} words found in "${r}":`),e.forEach((t=>i(t)))}}static hangmen(t,e,i){if(!e||0===e.length)throw Error("Need letters to find hangman matches for");for(const r of e)t.findHangmen(r.replace(/\./g," ")).forEach((t=>i(t)))}static arrangements(t,e,i){if(!e||0===e.length)throw Error("Need letters to find arrangements of");for(const r of e){let e=Object.keys(t.findAnagrams(r));i(`${e.length} words found in "${r}":`),e.forEach((t=>i(t)))}}static list(t,e,i){if(!e||0===e.length)return void t.eachWord(((t,e)=>i(t)));const r={};e.map((e=>{const i=e.toUpperCase(),r=t.match(i);if(r)return{word:i,node:r}})).filter((t=>t)).sort(((t,e)=>t.word.length>e.word.length?-1:t.word.length===e.word.length?0:1)).map((t=>{if(t.node.child){let e=[];r[t.word]=!0,t.node.child.eachWord(t.word,(t=>e.push(t))),e=e.filter((t=>!r[t])),e.forEach((t=>r[t]=!0)),i(e.map((e=>`${t.word} -- ${e}`)).join("\n"))}}))}}let s=0;class h{letter=void 0;id=-1;next=null;child=null;isEndOfWord=!1;isFirstChild=!1;isPruned=!1;maxChildDepth=0;numberOfChildren=0;index=-1;constructor(t,e,i,r,n){this.letter=t,this.next=e,this.isEndOfWord=i,this.maxChildDepth=r,this.isFirstChild=n,this.id=s++}toString(t){let e=`{${this.id} ${this.letter}`;return this.isEndOfWord&&(e+="."),this.child&&(e+="+",t&&(e+=this.child.toString(t))),e+="}",this.next&&(e+="-",t&&(e+=this.next.toString(t))),e}prune(){this.isPruned=!0;let t=0;return this.next&&(t+=this.next.prune()),this.child&&(t+=this.child.prune()),t+1}eachWord(t,e){t.push(this),this.isEndOfWord&&e(t),this.child&&this.child.eachWord(t,e),t.pop(),this.next&&this.next.eachWord(t,e)}eachNode(t){t(this),this.next&&this.next.eachNode(t),this.child&&this.child.eachNode(t)}findChild(t){let e=this.child;for(;e;){if(e.letter===t)return e;if(e.letter>t)break;e=e.next}return null}insertChild(t,e,i){if(this.numberOfChildren++,!this.child)return void(this.child=new h(t,null,e,i,!0));if(this.child.letter>t)return this.child.isFirstChild=!1,void(this.child=new h(t,this.child,e,i,!0));let r=this.child;for(;r.next&&!(r.next.letter>t);)r=r.next;r.next=new h(t,r.next,e,i,!1)}sameSubtrie(t){return!(t!==this&&(null===t||t.letter!==this.letter||t.maxChildDepth!==this.maxChildDepth||t.numberOfChildren!==this.numberOfChildren||t.isEndOfWord!==this.isEndOfWord||!this.child&&t.child||this.child&&!t.child||!this.next&&t.next||this.next&&!t.next||this.child&&!this.child.sameSubtrie(t.child)||this.next&&!this.next.sameSubtrie(t.next)))}findSameSubtrie(t){let e;for(e=0;e<t[this.maxChildDepth].length&&!this.sameSubtrie(t[this.maxChildDepth][e]);e++);if(t[this.maxChildDepth][e].isPruned)throw Error("Same subtrie equivalent is pruned!");return t[this.maxChildDepth][e]}replaceRedundantNodes(t){if(!this.next&&!this.child)return 0;let e=0;if(this.child)if(this.child.isPruned){if(this.child=this.child.findSameSubtrie(t),null===this.child)throw Error("Something horrible");e++}else e+=this.child.replaceRedundantNodes(t);return this.next&&(e+=this.next.replaceRedundantNodes(t)),e}encode(){const t=[this.letter.codePointAt(0)];let e=0;return this.child&&(e|=this.child.index<<i.CHILD_INDEX_SHIFT),this.isEndOfWord&&(e|=i.END_OF_WORD_BIT_MASK),this.next||(e|=i.END_OF_LIST_BIT_MASK),t.push(e),t}}class d{numberOfWords=0;numberOfNodes=0;maxWordLen=0;minWordLen=1e6;first=new h(-1,null,!1,0,0,null,!1);_debug=()=>{};constructor(t,e){"function"==typeof e&&(this._debug=e),this._debug("\nConstruct Trie and fill from lexicon");for(let e of t)this.addWord(e);this._debug(`Trie of ${this.numberOfNodes} nodes built from ${this.numberOfWords} words`)}addWord(t){let e=this.first,i=0;this.maxWordLen=Math.max(this.maxWordLen,t.length),this.minWordLen=Math.min(this.minWordLen,t.length);for(let r=0;r<t.length;r++){const n=e.child?e.findChild(t[r]):null;if(!n){e.insertChild(t[r],r===t.length-1,t.length-r-1),i++,e=e.findChild(t[r]);for(let n=r+1;n<t.length;n++)e.insertChild(t[n],n===t.length-1,t.length-n-1),i++,e=e.child;break}n.maxChildDepth<t.length-r-1&&(n.maxChildDepth=t.length-r-1),e=n,r===t.length-1&&(this._debug(`WARNING input not in alphabetical order ${t}`),e.isEndOfWord=!0)}this.numberOfNodes+=i,this.numberOfWords++}eachWord(t){this.first.eachWord([],t)}createReductionStructure(){this._debug("\nCreate reduction structure");const t=[];for(let e=this.minWordLen;e<this.maxWordLen;e++)t[e]=0;const e=[],i=[];let r=this.first.child;for(;r;)i.push(r),r=r.next;let n=0;for(;i.length>0;)for(r=i.shift(),e[r.maxChildDepth]||(e[r.maxChildDepth]=[]),e[r.maxChildDepth].push(r),t[r.maxChildDepth]++,n++,r=r.child;r;)i.push(r),r=r.next;for(let e=this.minWordLen;e<this.maxWordLen;e++)t[e]>0&&this._debug(`${t[e]} words of length ${e}`);return this._debug(`${n} nodes added to the reduction structure`),e}findPrunedNodes(t){this._debug("\nMark redundant nodes as pruned");let e=0;for(let i=t.length-1;i>=0;i--){let r=0;const n=t[i];for(let t=0;t<n.length-1;t++)if(!n[t].isPruned)for(let e=t+1;e<n.length;e++)!n[e].isPruned&&n[e].isFirstChild&&n[t].sameSubtrie(n[e])&&(r+=n[e].prune());this._debug(`Pruned |${r}| nodes at depth |${i}|`),e+=r}return this._debug(`Identified a total of ${e} nodes for pruning`),e}assignIndices(){this._debug("\nAssign node indices"),this.first.child.eachNode((t=>t.index=-1));let t=this.first.child;const e=[],i=[];for(;t;)e.push(t),t=t.next;let r=0;for(;e.length>0;)if(t=e.shift(),t.index<0)for(t.index=r++,i.push(t),t=t.child;t;)e.push(t),t=t.next;return this._debug(`Assigned ${r} node indexes`),i}generateDAWG(){const t=this.createReductionStructure(),e=this.findPrunedNodes(t);let i=this.first.child.replaceRedundantNodes(t);this._debug(`Decoupled ${i} nodes to eliminate ${e} nodes`),this.numberOfNodes-=e}encode(){this._debug("\nGenerate the unsigned integer array");const t=this.assignIndices();if(t.length>1073741823)throw Error("Too many nodes remain for integer encoding");this._debug(`\t${t.length} nodes`);const e=2*t.length+1,i=new ArrayBuffer(4*e),r=new DataView(i);let n=0;r.setUint32(n,t.length),n+=4;for(let e=0;e<t.length;e++){const i=t[e].encode();r.setUint32(n,i[0]),n+=4,r.setUint32(n,i[1]),n+=4}return this._debug(`\t${e} element Uint32Array generated`),i}}var o=e.Xy,l=e.bC,c=e.sn,a=e.BE,u=e.Yk;export{o as Dictionary,l as Explorer,c as LetterNode,a as Trie,u as TrieNode};